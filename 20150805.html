<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>iOS 开发之多线程 GCD | zerocc2014</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 开发之多线程 GCD</h1><a id="logo" href="/.">zerocc2014</a><p class="description">桃李春风一杯酒，江湖夜雨十年灯</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/reads/"><i class="fa fa-folder"> 阅读</i></a><a href="/codes/"><i class="fa fa-star"> 干货</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 开发之多线程 GCD</h1><div class="post-meta">2015年08月05日<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5"><span class="toc-number">1.</span> <span class="toc-text">同步&amp;异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-amp-%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">任务&amp;队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GCD-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">GCD 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-once-%EF%BC%88GCD-%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">dispatch_once （GCD 一次性代码执行）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-group%EF%BC%88GCD-%E9%98%9F%E5%88%97%E7%BB%84%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">dispatch_group（GCD 队列组）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-after%EF%BC%88GCD-%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">dispatch_after（GCD 延时执行）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-apply%EF%BC%88GCD-%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">dispatch_apply（GCD 快速迭代）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-source%EF%BC%88GCD-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">dispatch_source（GCD 实现定时器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-barrier-async%EF%BC%88GCD-%E6%A0%85%E6%A0%8F%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">dispatch_barrier_async（GCD 栅栏方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-semaphore%EF%BC%88GCD-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">dispatch_semaphore（GCD 信号量）</span></a></li></ol></li></ol></div></div><div class="post-content"><p><strong>Grand Central Dispatch（GCD）</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。GCD 可用于多核的并行运算；GCD 会自动利用更多的 CPU 内核（比如双核、四核）；GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；</p>
<a id="more"></a>

<h1 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h1><p>同步和异步的概念主要区别：具不具备开启新的线程的能力，决定了任务在哪一个线程执行了；但更确切的说同步（sync）和 异步（async）的区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕；同步（sync） 操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。异步（async）操作，当前线程会直接往下执行，它不会阻塞当前线程；</p>
<ul>
<li><p>同步：在当前线程中执行任务，不具备开启新线程的能力；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE dispatch_block_t block);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步：在新的线程中执行任务，具备开启新线程的能力；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="任务-amp-队列"><a href="#任务-amp-队列" class="headerlink" title="任务&amp;队列"></a>任务&amp;队列</h1><p>任务：即具体要干的事情要执行的操作，一般是一段代码块，在 GCD 中是一个 就是一个 Block 块，<strong>这里需要特意留意下任务是 Block 块</strong>；任务存放于队列中，任务有两种执行方式：是串行还是并行；同步和异步决定任务在那条线程中执行；</p>
<p>队列：用于存放任务，GCD 中队列分为两大类 <code>dispatch_queue_t</code>，串行队列 和 并行队列，队列的类型决定了任务的执行方式；</p>
<ul>
<li><p>串行队列：放到串行队列的任务，任务会以 FIFO（先进先出）的方式地取出来，让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务），实际上串行队列中也只能开启一条新线程；其中特殊的是系统自身就已经创建了一个主队列，对应着主线程其也是串行队列，主线程的作用是处理UI事件（点击事件、滚动事件、拖拽事情），串行队列的创建及获取有如下方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列 - 特殊的串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建队列 - 串行队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 创建队列</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 第一个参数： &quot;com.zerocc.testQueue&quot; 队列名 可用于 Instruments 的调试和 CrashLog 查看</span></span><br><span class="line"><span class="comment"> 第二个参数： NULL 指定为 NULL 或 DISPATCH_QUEUE_SERIAL,生成 Serial Dispatch Queue；</span></span><br><span class="line"><span class="comment"> 指定为 DISPATCH_QUEUE_CONCURRENT，生成 Concurrent Dispatch Queue。</span></span><br><span class="line"><span class="comment"> 返回值：    队列，dispatch_queue_t 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.test00Queue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.test01Queue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发队列：放到并发队列的任务，任务也是以 FIFO 的方式取出来，但不同的是，它取出来一个就会放到一个线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起并发执行的；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取全局并发队列</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 第一个参数：用于指定队列优先级 一般使用默认优先级即可 DISPATCH_QUEUE_PRIORITY_DEFAULT 0；其它三种有:</span></span><br><span class="line"><span class="comment">  DISPATCH_QUEUE_PRIORITY_HIGH  2，</span></span><br><span class="line"><span class="comment">  DISPATCH_QUEUE_PRIORITY_LOW  -2，</span></span><br><span class="line"><span class="comment">  DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 2 后台优先级</span></span><br><span class="line"><span class="comment"> 第二个参数：苹果预留设计传入0即可 0</span></span><br><span class="line"><span class="comment"> 返回值：   全局并发队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.test02Queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>总结：</p>
<ul>
<li><code>dispatch_sync</code> 同步执行不管任务是在串行队列还是在并行队列，任务都是在当前线程一个接一个执行(主队列特例除外例如子线程中调用 sync + 主队列那么任务会从子线程回到主线程执行) - <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync">apple documentation Discussion</a>；</li>
<li><code>dispatch_async</code> 异步执行任务放在串行队列，任务在其它线程一个接一个执行；任务放在并行队列，任务在多个线程中并发执行；</li>
</ul>
<h1 id="GCD-常用方法"><a href="#GCD-常用方法" class="headerlink" title="GCD 常用方法"></a>GCD 常用方法</h1><h2 id="dispatch-once-（GCD-一次性代码执行）"><a href="#dispatch-once-（GCD-一次性代码执行）" class="headerlink" title="dispatch_once （GCD 一次性代码执行）"></a>dispatch_once （GCD 一次性代码执行）</h2><p><code>dispatch_once</code> 能保证 Block 中代码块在程序运行过程只执行一次，常用于单例的创建；并且在多线程的环境下，dispatch_once 可以保证线程安全；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span> disaptchOnce];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)disaptchOnce &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;dispatch_once - 执行任务&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击后打印结果如下, disaptchOnce 方法调用了三次，其中 dispatch_once 的 block 代码块只执行一次</span></span><br><span class="line">... CCBlogCode[<span class="number">41182</span>:<span class="number">17902797</span>] -[CCGCDVC disaptchOnce]</span><br><span class="line">... CCBlogCode[<span class="number">41182</span>:<span class="number">17902797</span>] dispatch_once - 执行任务</span><br><span class="line">... CCBlogCode[<span class="number">41182</span>:<span class="number">17902797</span>] -[CCGCDVC disaptchOnce]</span><br><span class="line">... CCBlogCode[<span class="number">41182</span>:<span class="number">17902797</span>] -[CCGCDVC disaptchOnce]</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-group（GCD-队列组）"><a href="#dispatch-group（GCD-队列组）" class="headerlink" title="dispatch_group（GCD 队列组）"></a>dispatch_group（GCD 队列组）</h2><p>队列组可以将多个队列添加到一个组里，从而管理监听所有任务都执行完成情况，当所有任务都执行完成有一个回调监听。这里的多个队列可以是不同的；运用场景可以是多个网络请求的控制等例如表单类型填写上报优先级问题；实现步骤如下：</p>
<ul>
<li>创建队列组，通过调用 <code>dispatch_group_create()</code>方法创建得到 <code>dispatch_group_t</code> 类型 group；</li>
<li>将队列中的任务添加到队列组 group 中, 通过 <code>dispatch_group_async(队列组，队列，block)</code> 方法；次步也可以使用 <code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 这两个组合替代 <code>dispatch_group_async</code>, <code>dispatch_group_enter</code>：表示将一个队列中任务放入 group 队列组中，此时 group 队列组任务数加1, <code>dispatch_group_leave</code>：表示将一个队列中任务从 group 队列组撤出，此时 group 队列组任务数减1；一定是配合一对一使用否则 group 任务数不为0(也就是标志是否执行完)，任务数不为0则不会走下一步的监听回调 Block；</li>
<li>监听所有队列中任务完成的回调，具体任务完成回调监听方法 <code>dispatch_group_notify(队列组，队列，block)</code>；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCD 队列组常规使用</span></span><br><span class="line">- (<span class="keyword">void</span>)dispatchGroup &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="comment">// 1. 创建队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将队列中的任务添加到队列组 group 中</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1---%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2---%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3---%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 监听到所有队列中任务已完成</span></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务123都执行完毕---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果打印</span></span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621582</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x1cc07f3c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621582</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x1cc07f3c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621582</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x1cc07f3c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621584</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x1c4263e80</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621584</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x1c4263e80</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621584</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x1c4263e80</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621581</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c807db00</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621581</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c807db00</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621581</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c807db00</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1435</span>:<span class="number">621451</span>] 任务<span class="number">123</span>都执行完毕---&lt;NSThread: <span class="number">0x1d007c4c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCD 队列组 dispatch_group_enter 和 dispatch_group_leave 配合使用</span></span><br><span class="line">- (<span class="keyword">void</span>)dispatchGroupEnterAndleave</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列1任务1添加进 group 中</span></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列2任务2添加进 group 中</span></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// enter 和 leave 一定是成对的，例如任务2中 少了enter则执行完任务2直接走下面block回调，执行完任务1后会出现崩溃；</span></span><br><span class="line">    <span class="comment">// 如果少了leave则执行完任务1和2后不走下面block回调</span></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务12都执行完毕---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果打印</span></span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622770</span>] currentThread---&lt;NSThread: <span class="number">0x1d406f940</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622862</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x1c806c540</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622862</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x1c806c540</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622858</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c406cf40</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622858</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c406cf40</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1467</span>:<span class="number">622770</span>] 任务<span class="number">12</span>都执行完毕---&lt;NSThread: <span class="number">0x1d406f940</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>队列组中还有一个方法 <code>dispatch_group_wait(队列组, DISPATCH_TIME_FOREVER)</code>，可以用来阻塞当前线程，这里指的当前线程为队列组 group 所在的线程。</p>
<h2 id="dispatch-after（GCD-延时执行）"><a href="#dispatch-after（GCD-延时执行）" class="headerlink" title="dispatch_after（GCD 延时执行）"></a>dispatch_after（GCD 延时执行）</h2><p>GCD 延时执行就是针对某个队列中的任务 (block 块中）延迟执行，通过调用方法 <code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,         dispatch_block_t block)</code> 来指定某个任务在延迟特定的时间后再执行；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchAfter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主队列中任务3.0秒后延迟执行，这里也可以换成其它队列</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;延迟2秒执行---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-apply（GCD-快速迭代）"><a href="#dispatch-apply（GCD-快速迭代）" class="headerlink" title="dispatch_apply（GCD 快速迭代）"></a>dispatch_apply（GCD 快速迭代）</h2><p>GCD 快速迭代类似于 for 和 while 循环遍历，但是不同的是可以将执行任务代码块添加到指定队列中进行；如果任务在串行队列中执行使用 <code>dispatch_apply</code> 效果等同于一般 for 循环，如果是并发队列进行异步执行的话，<code>dispatch_apply</code> 可以在多个线程同时异步遍历执行，会自动开启新线程执行任务，并且执行的顺序是不固定的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCD 快速迭代 并发队列为例</span></span><br><span class="line">- (<span class="keyword">void</span>)dispatchApply &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;迭代---begin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;迭代%zd---%@&quot;</span>,index, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;迭代---end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果打印</span></span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814061</span>] 迭代---begin</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814061</span>] 迭代<span class="number">0</span>---&lt;NSThread: <span class="number">0x1d4260780</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814193</span>] 迭代<span class="number">1</span>---&lt;NSThread: <span class="number">0x1c807e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814426</span>] 迭代<span class="number">3</span>---&lt;NSThread: <span class="number">0x1c426c280</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814454</span>] 迭代<span class="number">5</span>---&lt;NSThread: <span class="number">0x1c0263fc0</span>&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814453</span>] 迭代<span class="number">4</span>---&lt;NSThread: <span class="number">0x1cc07e340</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814425</span>] 迭代<span class="number">2</span>---&lt;NSThread: <span class="number">0x1c02642c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814061</span>] 迭代<span class="number">6</span>---&lt;NSThread: <span class="number">0x1d4260780</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814426</span>] 迭代<span class="number">8</span>---&lt;NSThread: <span class="number">0x1c426c280</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814193</span>] 迭代<span class="number">7</span>---&lt;NSThread: <span class="number">0x1c807e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814454</span>] 迭代<span class="number">9</span>---&lt;NSThread: <span class="number">0x1c0263fc0</span>&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">2001</span>:<span class="number">814061</span>] 迭代---end</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-source（GCD-实现定时器）"><a href="#dispatch-source（GCD-实现定时器）" class="headerlink" title="dispatch_source（GCD 实现定时器）"></a><code>dispatch_source</code>（GCD 实现定时器）</h2><p>dispatch_source… 的使用，其中通过调用方法<code>dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue)</code>创建事件，第一个参数为 <code>dispatch_source_type_t</code> 类型，其代表指定事件类型，可以自定义事件或者 Timer 事件还有 Mach 端口相关事件等等，可以 command 点进去看API了；此文只对定时器事件运用分析。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchSource &#123;</span><br><span class="line">    __block <span class="keyword">int</span> timeout = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取全局队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1. 创建GCD中的定时器,并将定时器的任务交给全局并发队列执行(不会造成主线程阻塞)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     第一个参数: DISPATCH_SOURCE_TYPE_TIMER source的类型 DISPATCH_SOURCE_TYPE_TIMER 表示是定时器</span></span><br><span class="line"><span class="comment">     第二个参数: 0</span></span><br><span class="line"><span class="comment">     第三个参数: 0</span></span><br><span class="line"><span class="comment">     第四个参数: queue 队列</span></span><br><span class="line"><span class="comment">     返回值： timer dispatch_source_t 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置定时器(timer 定时器，起始时间，间隔时间，精准度); 1.0 * NSEC_PER_SEC 时间单位为纳秒，设置定时器触发的时间间隔为1s; 0 * NSEC_PER_SEC 精确度 0s</span></span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// block内部 使用弱引用修饰 避免循环调用</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    weakSelf.timerBtn.userInteractionEnabled = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置定时器的触发事件</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        timeout--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 回到主队列主线程设置 UI</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="built_in">NSString</span> * title = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d秒后重新&quot;</span>,timeout];</span><br><span class="line">                [weakSelf.timerBtn setTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 取消定时器</span></span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 取消定时器回调</span></span><br><span class="line">    dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            weakSelf.timerBtn.userInteractionEnabled = <span class="literal">YES</span>;</span><br><span class="line">            [weakSelf.timerBtn setTitle:<span class="string">@&quot;重新获取&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;定时取消&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-async（GCD-栅栏方法）"><a href="#dispatch-barrier-async（GCD-栅栏方法）" class="headerlink" title="dispatch_barrier_async（GCD 栅栏方法）"></a><code>dispatch_barrier_async</code>（GCD 栅栏方法）</h2><p><code>dispatch_barrier_async</code>作用就是分割其上下两部分任务执行过程，都是异步执行但是先执行其前面的任务先，再执行自身 Block 块中的任务，最后继续往下执行；表现形式就是分割作用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchBarrier &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;zerocc.com.testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务1</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务2</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// barrier 分割等待</span></span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;barrier---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务3</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果打印</span></span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604551</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x600001bc0300</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604551</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x600001bc0300</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] barrier---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] barrier---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">30046</span>:<span class="number">4604553</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x600001bc0900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-semaphore（GCD-信号量）"><a href="#dispatch-semaphore（GCD-信号量）" class="headerlink" title="dispatch_semaphore（GCD 信号量）"></a>dispatch_semaphore（GCD 信号量）</h2><p>GCD 信号量可以理解为一个计数器，用来控制线程并发访问的最大数量问题，保证线程同步等。信号量初始值为1，代表只允许当前线程访问资源，当信号量值小与等于零时当前线程就进入休眠等待状态。</p>
<ul>
<li>初始化信号量，调用 <code>dispatch_semaphore_create(1)</code> 方法初始化信号量值为1；</li>
<li>判断信号量值决定其是否能往下继续执行，通过调用方法 <code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)</code>。如果信号量的值大于0，则该方法所处的线程就会继续执行，并且信号量值 -1；如果信号量值 &lt;= 0, 当前线程进入休眠等待状态，也可以通过控制第二个参数使其不一直处于等待状态，例如：DISPATCH_TIME_NOW+3 表示3秒后继续向下执行；</li>
<li>一个任务执行完后记得使信号量的值加1，通过调用方法 <code>dispatch_semaphore_signal</code>信号值 +1，从而后面任务可以继续执行；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchSemaphore &#123;</span><br><span class="line">    <span class="comment">// 创建并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.zerocc.semaphore&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化信号量值为1</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务1</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 2. 判断信号量值, 信号量 &gt; 0 继续执行并且信号量值 -1；信号量 &lt;= 0, 当前线程进入休眠等待状态</span></span><br><span class="line">        <span class="comment">// 这里信号量为0了，所以任务2要等待ing</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// 3. 信号量值 +1</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 任务2</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 任务3</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果打印, 任务123先后顺序并不确定，但是是连续的，也就是说一定是保证只有一个线程执行任务，其它线程则是等待状态</span></span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347237</span>] 任务<span class="number">1</span>---&lt;NSThread: <span class="number">0x600003f3d9c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347235</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x600003f3f1c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347235</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x600003f3f1c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347235</span>] 任务<span class="number">2</span>---&lt;NSThread: <span class="number">0x600003f3f1c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347234</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x600003f3dc80</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347234</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x600003f3dc80</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">... CCBlogCode[<span class="number">1688</span>:<span class="number">347234</span>] 任务<span class="number">3</span>---&lt;NSThread: <span class="number">0x600003f3dc80</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

























</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>iOS 开发之多线程 GCD</p><p><span>文章作者：</span>zerocc</p><p><span>发布时间：</span>2015年08月05日</p><p><span>原始链接：</span><a href="/20150805.html">http://www.zerocc.com.cn/20150805.html</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="http://www.zerocc.com.cn/20150805.html"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.zerocc.com.cn/20150805.html" data-id="ckfp6faph001zjdxbcbnw4bue" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAByUlEQVR42u3aMW4DMQwEQP//05c2RXy3pCTaAUZVkBjyKMWCovh6xev6td795v6T7/Z8nVi4uLjL3Ot25dx39Pvvyg24uLjz3PugySMsCcH7/R/2xMXF/Upur0CphiAuLu5/5yYxt+2ChIuLO8hNLj+9FklCPHJXw8XFXeD2CpS9Px/p7+Li4ra4V3ElIbUrvP7YExcXd4SbB0r1ceW+QMnLF1xc3M9yq+MU+efX5ysKf8bFxT3AzYcnkhDsBV9U4uDi4h7m9voP1SMlQ1r5t+Di4s5wqxeSamwlRUyhYMLFxR3k7tq62nLNxz5wcXFnuL32ZV7K5BeqaE9cXNxBbm8AK8nIaoQ9hCYuLu4IN38g6T2u9GarCnc1XFzcw9xdgxTV55A8BHFxcWe4Kw2L6mGqjZKHyw8uLu4IN7/qJL9JDpMfEhcXd57ba5hG1VNxFWZDcHFxD3Cv4soLl+o+0VFxcXFHuNVwSYKsV+JU2y64uLinuXnoVJ9CV4KsWejg4uJu5eZBkxc35XtYHmS4uLhfxk0QKyXR5iDDxcUd4VaPUR3FeBDi4uIOcntN0uqwRfIo+/BPwcXFHeH2Hj5Xrje9Z11cXNwR7g//8AsJUmyvDAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/iOS/"><i class="fa fa-tag"></i>iOS</a></div><div class="post-nav"><a class="pre" href="/20150806.html">iOS 开发之多线程 NSOperation</a><a class="next" href="/20150803.html">iOS 开发之多线程开篇</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMTcyMy84Mjg3"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.zerocc.com.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E5%85%89%E6%B2%99%E6%BC%8F/">时光沙漏</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/index.html">iOS - RunLoop 具体运用</a></li><li class="post-list-item"><a class="post-list-link" href="/20151003.html">iOS 开发之 Socket 编程</a></li><li class="post-list-item"><a class="post-list-link" href="/20180101.html">归来仍是少年</a></li><li class="post-list-item"><a class="post-list-link" href="/20161023.html">只要最后是你就好</a></li><li class="post-list-item"><a class="post-list-link" href="/20190602.html">后来的我们</a></li><li class="post-list-item"><a class="post-list-link" href="/20181017.html">凌晨三点</a></li><li class="post-list-item"><a class="post-list-link" href="/20160405.html">念乡思你</a></li><li class="post-list-item"><a class="post-list-link" href="/20170420.html">漂洋过海来看你</a></li><li class="post-list-item"><a class="post-list-link" href="/index.html">iOS - 苹果内购</a></li><li class="post-list-item"><a class="post-list-link" href="/20180312.html">希望我们冷漠且礼貌的相处</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 22.5px;">随笔</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 17.5px;">心情</a> <a href="/tags/iOS/" style="font-size: 25px;">iOS</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 20px;">源码阅读</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">zerocc2014.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>