<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>iOS 开发之 Socket 编程 | zerocc2014</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 开发之 Socket 编程</h1><a id="logo" href="/.">zerocc2014</a><p class="description">桃李春风一杯酒，江湖夜雨十年灯</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/reads/"><i class="fa fa-folder"> 阅读</i></a><a href="/codes/"><i class="fa fa-star"> 干货</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 开发之 Socket 编程</h1><div class="post-meta">2019年08月23日</div><div class="post-content"><a id="more"></a>

<h1 id="一-Socket-基础知识"><a href="#一-Socket-基础知识" class="headerlink" title="一. Socket 基础知识"></a>一. Socket 基础知识</h1><p>Socket 套接字是基于 TCP/IP 的一种封装，是一个抽象层，也就是说提供一套 Socket API 方便我们使用 TCP/IP 端对端的 IO 传输；Socket 编程中最常使用的两种协议，即面向连接的 TCP 协议和无连接的 UDP 协议；</p>
<p>TCP/IP 概念层模型：应用层、传输层、网络层、数据链路层；TCP/UDP 是传输层协议主要是提供端对端的接口；IP 协议位于网络层主要是为数据包选择路由；</p>
<p><strong>对于 TCP 协议</strong></p>
<p>TCP连接过程：建立连接三次握手、数据传输、断开连接四次挥手；</p>
<p>三次握手：</p>
<ol>
<li>客户端向服务端发送连接请求报文段 SYN 包 (SYN=J)。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，等待服务器确认；</li>
<li>服务端收到连接请求报文段 SYN 包后，如果同意连接，确认客户端的SYN(ACK=J+1)，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号 SYN(SYN=K)包也就是 SYN+ACK 包，发送完成后服务器便进入 SYN-RECEIVED 状态。</li>
<li>当客户端收到连接同意的应答 SYN+ACK 包后，还要向服务端发送一个确认报文 ACK(ACK=K+1) 包。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ol>
<p>四次挥手：</p>
<ol>
<li>若客户端认为数据发送完成，则它需要向服务端发送 FIN 的报文连接释放请求，客户端进入等待服务器的响应；</li>
<li>服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK (ACK=X+1）包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li>服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求 FIN 的报文，然后服务端便进入 LAST-ACK 状态。</li>
<li>客户端收到释放请求后，向服务端发送确认应答 ACK，此时客户端进入 TIME-WAIT 状态。该状态会持续 2 MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ol>
<p><strong>对于 UDP 协议</strong></p>
<p>UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作；</p>
<p>UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显</p>
<p>UDP 提供了单播，多播，广播的功能；</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h1 id="二-BSD-Socket-基本使用相关-API-详解"><a href="#二-BSD-Socket-基本使用相关-API-详解" class="headerlink" title="二. BSD Socket 基本使用相关 API 详解"></a>二. BSD Socket 基本使用相关 API 详解</h1><p>BSD Socket 是 unix 系统下的 Socket API 可以跨平台使用，API 接口纯 C 语言编写，使用需先导入相关头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BSD socket 核心函数和数据结构。</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// AF_INET 和AF_INET6 地址家族和他们对应的协议家族 PF_INET 和 PF_INET6</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 和IP地址相关的一些函数</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>1. 客户端简单实现分如下五个步骤：</strong></p>
<p><strong>1.1 创建 socket</strong></p>
<p>创建 socket 套接字调用函数如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> socket(<span class="built_in">int</span> domain, <span class="built_in">int</span> type, <span class="built_in">int</span> protocol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">int</span> socketID = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 domain: <code>AF_INET</code>, 协议域又称协议族（family）；常用的协议族有<code>AF_INET</code>( ipv4 )、<code>AF_INET6</code>( ipv6 )、<code>AF_LOCAL</code>（或称 <code>AF_UNIX</code>，Unix 域 Socket）、<code>AF_ROUTE</code>等；协议族决定了 socket 的地址类型，在通信中必须采用对应的地址，如 <code>AF_INET</code> 决定了要用 ipv4 地址（32位的）与端口号（16位的）的组合、<code>AF_UNIX</code>决定了要用一个绝对路径名作为地址；</li>
<li>第二个参数 type: <code>SOCK_STREAM</code>, 指定 Socket 类型;常用的 socket 类型有 <code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等；流式Socket（ <code>SOCK_STREAM</code> ）是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用。数据报式Socket（ <code>SOCK_DGRAM</code> ）是一种无连接的 Socket，对应于无连接的 UDP 服务应用。</li>
<li>第三个参数 protocol: 0 , 指定协议；常用协议有 <code>IPPROTO_TCP</code>( TCP 传输协议 )、 <code>IPPROTO_UDP</code>( UDP 传输协议 )、<code>IPPROTO_STCP</code>( STCP 传输协议 )、<code>IPPROTO_TIPC</code>(TIPC 传输协议)等；type 和 protocol 不可以随意组合，如 <code>SOCK_STREAM</code> 不可以跟 <code>IPPROTO_UDP</code> 组合。当第三个参数为 0 时，会自动选择第二个参数类型对应的默认协议；</li>
<li>返回值 socketID， 如果调用成功就返回新创建的套接字的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）；</li>
</ul>
<p><strong>1.2 建立连接</strong></p>
<p>建立连接调用函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> connect(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">struct</span> in_addr  socketIn_addr;</span><br><span class="line">socketIn_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in socketAddr;</span><br><span class="line">socketAddr.sin_family = AF_INET;</span><br><span class="line">socketAddr.sin_port = htons(<span class="number">8029</span>);</span><br><span class="line">socketAddr.sin_addr = socketIn_addr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> result = connect(socketID, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;socketAddr, <span class="keyword">sizeof</span>(socketAddr));</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;socket 连接成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;socket 连接失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 sockfd：套接字的描述符；</li>
<li>第二个参数 * addr：指向数据结构 sockaddr 的指针，其中包括目的端口和IP地址也就是服务器端的地址；</li>
<li>第三个参数 addrlen：sockaddr的长度，可以通过sizeof（struct sockaddr）获得；</li>
<li>返回值 int型：成功则返回0，失败返回非0，错误码 GetLastError()；</li>
</ul>
<p>IP 地址的表示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4 地址用一个 32 位整数来表示</span></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in &#123;</span><br><span class="line">[object Object]__uint8_t	sin_len;		<span class="comment">// 地址长度</span></span><br><span class="line">[object Object]sa_family_t	sin_family;		<span class="comment">// IP 地址协议族，必须设为 AF_INET；PF_INET（协议族）</span></span><br><span class="line">[object Object]in_port_t	sin_port;		<span class="comment">// 端口</span></span><br><span class="line">[object Object]<span class="keyword">struct</span>	in_addr sin_addr;		<span class="comment">// 以网络字节排序的 4 字节 IPv4 地址</span></span><br><span class="line">[object Object]<span class="keyword">char</span>		sin_zero[<span class="number">8</span>];		<span class="comment">// 没有实际意义，是为了让 sockaddr_in 与 sockaddr 两个数据结构保持大小相同内存对齐作用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> in_addr &#123;</span><br><span class="line">   uint32_t  s_addr;		<span class="comment">// 按照网络字节顺序存储 IP 地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv6 地址用一个 128 位整数来表示</span></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in6 &#123;</span><br><span class="line">[object Object]__uint8_t	sin6_len;		<span class="comment">// 地址长度</span></span><br><span class="line">[object Object]sa_family_t	sin6_family;		<span class="comment">// IP 地址协议族，必须设为 AF_INET6</span></span><br><span class="line">[object Object]in_port_t	sin6_port;		<span class="comment">// 端口</span></span><br><span class="line">[object Object]__uint32_t	sin6_flowinfo;		<span class="comment">// 标记连接通信量</span></span><br><span class="line">[object Object]<span class="keyword">struct</span> in6_addr	sin6_addr;		<span class="comment">// 以网络字节排序的 6 字节 IPv6 地址</span></span><br><span class="line">[object Object]__uint32_t	sin6_scope_id;		<span class="comment">// 地址所在的接口索引（范围 ID）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> in6_addr &#123;</span><br><span class="line">[object Object]<span class="keyword">union</span> &#123;</span><br><span class="line">[object Object][object Object]__uint8_t   __u6_addr8[<span class="number">16</span>];</span><br><span class="line">[object Object][object Object]__uint16_t  __u6_addr16[<span class="number">8</span>];</span><br><span class="line">[object Object][object Object]__uint32_t  __u6_addr32[<span class="number">4</span>];</span><br><span class="line">[object Object]&#125; __u6_addr;			<span class="comment">/* 128-bit IP6 address */</span></span><br><span class="line">&#125; in6_addr_t;</span><br></pre></td></tr></table></figure>

<p>htons(8029) 函数执行是将一个无符号短整型的主机数值转换为网络字节顺序，不同 cpu 是不同的顺序 (big-endian 大端模式, little-endian 小端模式)；</p>
<p>inet_addr(“127.0.0.1”) 函数执行是将一个点分十进制的 IP 转换成一个长整数型数；每台机器都有自己的本地回环地址，IP 为 127.0.0.1 ，主机名为 localhost。如果 127.0.0.1 ping 不通，则网卡不正常。</p>
<p><strong>1.3 发送数据</strong></p>
<p>向服务端发送数据，调用函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, size_t size, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *msg =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;zerocc 发送消息&quot;</span>].UTF8String;</span><br><span class="line">ssize_t sendLen = send(<span class="keyword">self</span>.socketID, msg, strlen(msg), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数 sockfd：一个用于标识已连接套接口的描述符；</li>
<li>第二个参数 * buf：包含待发送数据的缓冲区；</li>
<li>第三个参数 size：缓冲区中数据的长度，strlen() 函数计算发送内容字节长度；</li>
<li>第四个参数 flags：调用执行方式一般为 0；</li>
</ul>
<p><strong>1.4 接收数据</strong></p>
<p>接收服务端数据，调用函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> * buf, size_t size, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">uint8_t buffer[<span class="number">1024</span>];</span><br><span class="line">ssize_t recvLen = recv(<span class="keyword">self</span>.socketID, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：客户端socket；</li>
<li>buf：接收内容缓冲区地址；</li>
<li>size：接收内容缓存区长度；</li>
<li>flags：接收方式，0表示阻塞，必须等待服务器返回数据；</li>
<li>返回值，如果成功，则返回读入的字节数，失败则返回SOCKET_ERROR；</li>
</ul>
<p><strong>1.5 关闭连接</strong></p>
<p>断开连接，调用函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> close(<span class="keyword">int</span> sockfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">close(<span class="keyword">self</span>.socketID);</span><br></pre></td></tr></table></figure>

<p><strong>2. 服务端简单实现分如下七个步骤：</strong></p>
<p><strong>2.1 创建 socket (同客户端)</strong></p>
<p><strong>2.2 绑定地址</strong></p>
<p>绑定一个地址 (ip地址+端口号)，用于客户端连接服务器，客户端这步不需要不用指定 ip 地址和端口号，系统会自动分配一个端口号和自身的 ip 地址，服务端调用 bind() 函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bind(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">struct</span> in_addr  socketIn_addr;</span><br><span class="line">socketIn_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in socketAddr;</span><br><span class="line">socketAddr.sin_family = AF_INET;</span><br><span class="line">socketAddr.sin_port = htons(<span class="number">8029</span>);</span><br><span class="line">socketAddr.sin_addr = socketIn_addr;</span><br><span class="line">bzero(&amp;(socketAddr.sin_zero), <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 绑定成功返回值为 0，失败为 -1</span></span><br><span class="line"><span class="keyword">int</span> bind_result = bind(<span class="keyword">self</span>.socketID, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;socketAddr, <span class="keyword">sizeof</span>(socketAddr));</span><br></pre></td></tr></table></figure>

<p><strong>2.3 监听等待客户端的连接请求</strong></p>
<p>服务端监听 socket 等待客户端的连接请求，调用的 listen() 如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> listen(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 第二个参数：socket 可以排队的最大连接个数</span></span><br><span class="line"><span class="keyword">int</span> listen_result = listen(<span class="keyword">self</span>.socketID, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2.4 接受客户端连接</strong></p>
<p>服务端监听到客户端的连接请求之后，就会调用 accept() 函数去接收连接请求，accept() 函数返回成功后就和客户端建立连接了，accept() 函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accept(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr * addr, socklen_t * addrlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in client_address;</span><br><span class="line">socklen_t address_len;</span><br><span class="line"><span class="keyword">int</span> client_socket = accept(<span class="keyword">self</span>.socketID, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line"><span class="keyword">self</span>.client_socket = client_socket;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 sockfd：服务端创建的 socket 套接字描述符；</li>
<li>第二个参数 addr：返回客户端的地址；</li>
<li>第三个参数 addrlen：addr 的长度；</li>
<li>返回值 client_socket：返回的也是  socket 套接字描述符，但是这个描述符是调用 accept 函数后生成的，是和客户端连接成功后的不同于自己创建的；</li>
</ul>
<p><strong>2.5 接收客户端传来的数据(同客户端)</strong></p>
<p>不同于客户端，特别注意这里要使用 2.4 步中返回的 client_socket 套接字描述符</p>
<p><strong>2.6 服务端发送数据(同客户端)</strong></p>
<p>不同于客户端，特别注意这里要使用 2.4 步中返回的 client_socket 套接字描述符</p>
<p><strong>2.7 关闭连接 (同客户端)</strong></p>
<h1 id="三-Socket-简单运用实例"><a href="#三-Socket-简单运用实例" class="headerlink" title="三. Socket 简单运用实例"></a>三. Socket 简单运用实例</h1><p><strong>1. 简单 demo</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;CCBSDSocketVC.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CCBSDSocketVC</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *connectBtn;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *msgTextField;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *sendBtn;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextView</span> *receiveTextView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableAttributedString</span> *receiveTextViewAttributeStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> socketID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CCBSDSocketVC</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setupUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupUI &#123;</span><br><span class="line">    <span class="keyword">self</span>.connectBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="keyword">self</span>.connectBtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">64</span>+<span class="number">20</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.connectBtn.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span>.connectBtn setTitle:<span class="string">@&quot;连接&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [<span class="keyword">self</span>.connectBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(connectBtnClicked) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.connectBtn];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.msgTextField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">30</span>, <span class="number">140</span>, <span class="number">200</span>, <span class="number">30</span>)];</span><br><span class="line">    <span class="keyword">self</span>.msgTextField.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">self</span>.msgTextField.borderStyle = <span class="built_in">UITextBorderStyleRoundedRect</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.msgTextField];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.sendBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="keyword">self</span>.sendBtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">250</span>, <span class="number">140</span>, <span class="number">60</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">self</span>.sendBtn.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span>.sendBtn setTitle:<span class="string">@&quot;发送&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [<span class="keyword">self</span>.sendBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(sendBtnClicked) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.sendBtn];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.receiveTextView = [[<span class="built_in">UITextView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">30</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line">    <span class="keyword">self</span>.receiveTextView.scrollEnabled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.receiveTextView.editable = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span>.receiveTextView.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.receiveTextView];</span><br><span class="line">    <span class="keyword">self</span>.receiveTextViewAttributeStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 5. 断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.socketID) &#123;</span><br><span class="line">        close(_socketID);</span><br><span class="line">        [<span class="keyword">self</span>.connectBtn setTitle:<span class="string">@&quot;连接&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectBtnClicked &#123;</span><br><span class="line">    <span class="comment">// 1. 创建socket</span></span><br><span class="line">    _socketID = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 建立连接</span></span><br><span class="line">    <span class="keyword">struct</span> in_addr  socketIn_addr;</span><br><span class="line">    socketIn_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in socketAddr;</span><br><span class="line">    socketAddr.sin_family = AF_INET;</span><br><span class="line">    socketAddr.sin_port = htons(<span class="number">8029</span>);</span><br><span class="line">    socketAddr.sin_addr = socketIn_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = connect(_socketID, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;socketAddr, <span class="keyword">sizeof</span>(socketAddr));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;socket 连接成功&quot;</span>);</span><br><span class="line">        [<span class="keyword">self</span>.connectBtn setTitle:<span class="string">@&quot;连接成功&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> receiveMessage];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;socket 连接失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendBtnClicked &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="keyword">self</span>.msgTextField.text.UTF8String;</span><br><span class="line">    <span class="comment">// 3. 发送数据</span></span><br><span class="line">    ssize_t sendLength = send(<span class="keyword">self</span>.socketID, msg, strlen(msg), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;发送了:%ld字节 \n %@&quot;</span>,sendLength, <span class="keyword">self</span>.msgTextField.text);</span><br><span class="line">    [<span class="keyword">self</span> showMsg:<span class="keyword">self</span>.msgTextField.text msgType:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">self</span>.msgTextField.text = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)receiveMessage &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        uint8_t buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 4. 接收数据</span></span><br><span class="line">        ssize_t receiveLength = recv(<span class="keyword">self</span>.socketID, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (receiveLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *receiveData  = [<span class="built_in">NSData</span> dataWithBytes:buffer length:receiveLength];</span><br><span class="line">            <span class="built_in">NSString</span> *receiveStr = [[<span class="built_in">NSString</span> alloc] initWithData:receiveData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;接收了:%ld字节 \n %@&quot;</span>,receiveLength, receiveStr);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> showMsg:receiveStr msgType:<span class="number">1</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showMsg:(<span class="built_in">NSString</span> *)msg msgType:(<span class="keyword">int</span>)msgType&#123;</span><br><span class="line">    <span class="built_in">NSMutableParagraphStyle</span> *paragraphStyle = [[<span class="built_in">NSMutableParagraphStyle</span> alloc] init];</span><br><span class="line">    paragraphStyle.headIndent = <span class="number">20.</span>f;</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedString;</span><br><span class="line">    <span class="keyword">if</span> (msgType == <span class="number">0</span>) &#123; <span class="comment">// 我发送的</span></span><br><span class="line">        attributedString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:msg];</span><br><span class="line">        paragraphStyle.alignment = <span class="built_in">NSTextAlignmentRight</span>;</span><br><span class="line">        [attributedString addAttributes:@&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>],</span><br><span class="line">                                          <span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> whiteColor],</span><br><span class="line">                                          <span class="built_in">NSBackgroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">                                          <span class="built_in">NSParagraphStyleAttributeName</span>:paragraphStyle&#125; range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, msg.length)];</span><br><span class="line">        [attributedString appendAttributedString:[[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 接收到的</span></span><br><span class="line">        attributedString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:msg];</span><br><span class="line">        [attributedString addAttributes:@&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>],</span><br><span class="line">                                          <span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blackColor],</span><br><span class="line">                                          <span class="built_in">NSBackgroundColorAttributeName</span>:[<span class="built_in">UIColor</span> whiteColor],</span><br><span class="line">                                          <span class="built_in">NSParagraphStyleAttributeName</span>:paragraphStyle&#125; range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, msg.length)];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.receiveTextViewAttributeStr appendAttributedString:attributedString];</span><br><span class="line">    [<span class="keyword">self</span>.receiveTextViewAttributeStr appendAttributedString:[[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    <span class="keyword">self</span>.receiveTextView.attributedText = <span class="keyword">self</span>.receiveTextViewAttributeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Netcat 的使用创建 TCP/UDP 连接和监听</strong></p>
<p>可以使用man 指令查看指令相关介绍：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span><span class="symbol">:~</span> zerocc<span class="variable">$ </span>man nc</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">     nc -- arbitrary TCP <span class="keyword">and</span> UDP connections <span class="keyword">and</span> listens</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     nc [-46AcDCdhklnrtUuvz] [-b boundif] [-i interval] [-p source_port] [-s source_ip_address] [-w timeout]</span><br><span class="line">        [-X proxy_protocol] [-x proxy_address[:port]] [--apple-delegate-pid pid] [--apple-delegate-uuid uuid]</span><br><span class="line">        [--apple-ext-bk-idle] [--apple-nowakefromsleep] [--apple-ecn mode] [hostname] [port[s]]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">     The nc (<span class="keyword">or</span> netcat) utility is used <span class="keyword">for</span> just about anything under the sun involving TCP <span class="keyword">or</span> UDP.  It can open TCP</span><br><span class="line">     connections, send UDP packets, listen on arbitrary TCP <span class="keyword">and</span> UDP ports, <span class="keyword">do</span><span class="built_in"> port </span>scanning, <span class="keyword">and</span> deal with both IPv4</span><br><span class="line">     <span class="keyword">and</span> IPv6.  Unlike telnet(1), nc scripts nicely, <span class="keyword">and</span> separates <span class="builtin-name">error</span> messages onto standard <span class="builtin-name">error</span> instead of send-</span><br><span class="line">     ing them <span class="keyword">to</span> standard output, as telnet(1) does with some.</span><br><span class="line"></span><br><span class="line">     Common uses include:</span><br><span class="line"></span><br><span class="line">           o  <span class="built_in"> simple </span>TCP proxies</span><br><span class="line">           o   shell-script based HTTP clients <span class="keyword">and</span> servers</span><br><span class="line">           o  <span class="built_in"> network </span>daemon testing</span><br><span class="line">           o   a<span class="built_in"> SOCKS </span><span class="keyword">or</span> HTTP ProxyCommand <span class="keyword">for</span> ssh(1)</span><br><span class="line">           o   <span class="keyword">and</span> much, much more</span><br><span class="line"></span><br><span class="line">     The options are as follows:</span><br><span class="line"></span><br><span class="line">     -4      Forces nc <span class="keyword">to</span> use IPv4 addresses only.</span><br><span class="line"></span><br><span class="line">     -6      Forces nc <span class="keyword">to</span> use<span class="built_in"> IPv6 </span>addresses only.</span><br><span class="line"></span><br><span class="line">     -A      <span class="builtin-name">Set</span> SO_RECV_ANYIF on socket.</span><br><span class="line"></span><br><span class="line">     -b boundif</span><br><span class="line">             Specifies the<span class="built_in"> interface </span><span class="keyword">to</span> bind the socket <span class="keyword">to</span>.</span><br><span class="line"></span><br><span class="line">     -c      Send CRLF as line-ending</span><br><span class="line"></span><br><span class="line">     -D      <span class="builtin-name">Enable</span> debugging on the socket.</span><br><span class="line"></span><br><span class="line">     -C      Forces nc <span class="keyword">not</span> <span class="keyword">to</span> use cellular data context.</span><br><span class="line"> :</span><br></pre></td></tr></table></figure>

<p>使用命令 <code>-l</code> 开启监听模式，代表着为一个服务等待客户端来连接指定的端口。强制 nc 待命连接，当客户端从服务端断开连接后，过一段时间服务端也会停止监听，但通过选项 <code>-k</code> 我们可以强制服务器保持连接并继续监听端口。</p>
<p>端口号：用于标示进程的逻辑地址，不同进程的标示。有效端口为 0 ~ 65535，其中 0 ~ 1024 由系统使用或者保留端口，开发中不要使用 1024 以下的端口。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span>:~ zerocc$ nc -lk <span class="number">8029</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 发送和接收数据测试</strong></p>
<p>客户端发送数据：11、Aaa;</p>
<p>终端服务发送数据：我们、zerocc</p>
<img src="iOS-开发之-Socket-编程/socket1.png" width = "300" height = "" alt="图片名称" align=left />


<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终端监听结果和发送数据</span></span><br><span class="line"><span class="number">192</span>:~ zerocc$ man nc</span><br><span class="line"><span class="number">192</span>:~ zerocc$ man nc</span><br><span class="line"><span class="number">192</span>:~ zerocc$ nc -lk <span class="number">8029</span></span><br><span class="line"><span class="number">11</span>Aaa我们</span><br><span class="line">zerocc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xcode log 打印</span></span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841398</span>] socket 连接成功</span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841398</span>] [MC] Reading <span class="keyword">from</span> <span class="keyword">private</span> effective user settings.</span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841398</span>] 发送了:<span class="number">2</span>字节 </span><br><span class="line"> <span class="number">11</span></span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841398</span>] 发送了:<span class="number">3</span>字节 </span><br><span class="line"> Aaa</span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841474</span>] 接收了:<span class="number">7</span>字节 </span><br><span class="line"> 我们</span><br><span class="line">... CCBlogCode[<span class="number">55724</span>:<span class="number">17841474</span>] 接收了:<span class="number">7</span>字节 </span><br><span class="line"> zerocc</span><br></pre></td></tr></table></figure>

<p>看到log 应该会有疑问：为啥终端服务发送过来 <code>我们</code> 是 7个字节，正确的应该是一个中文字符 utf-8 对应应该是 3 个字节，原因是因为终端发送带了换行符占了一个字节；</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/nc_netcat">nc/netcat命令</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/blueman2012/article/details/6693605">BSD Socket API </a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/1378445/blog/340206">iOS的 socket 开发基础 oschina</a></p>
</blockquote>
<ul>
<li><ol>
<li>登录接口</li>
</ol>
</li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>iOS 开发之 Socket 编程</p><p><span>文章作者：</span>zerocc</p><p><span>发布时间：</span>2019年08月23日</p><p><span>原始链接：</span><a href="/20151003.html">http://www.zerocc.com.cn/20151003.html</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="http://www.zerocc.com.cn/20151003.html"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.zerocc.com.cn/20151003.html" data-id="ckfp6oj3p00210kxbcv3nbsxr" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABzUlEQVR42u3aQVLDMAwF0N7/0uUAIeFLsk1hXlYMofUziz+WrNcrft6X5/r2+pfXt3efWvzg4uKOue/HJ+HeLX/3m+T7b9fCxcU9yH1e/jl0km0k8ReFHS4u7kdyo7gJvg0XF/c/cZNPVYMPFxf3M7lJ8ZNHVTW8ttRquLi4A27epdz385b+Li4ubov7Lj5JSK0Kr2++ExcX9wi3enxZdUCpNlNwcXFPcvPlJ+G1bNQDFxf3CHdeAiWN0eco7B2wcHFxd3Or15/J22RjOREXF/ckdzJ6lSyQFD+FzePi4h7h5mVMHje9lmselLi4uOe55TGpYiMjP+hEQYaLi7uNmw9XJcVMsoH50QcXF3c3Nz+OzHuxk2MTLi7ub3HzlmhvujI/+jSLH1xc3A3cZNhiPs6VH33KDVNcXNwj3Hwz1RGNpASKih9cXNwj3OoyySGmN/5Vrp9wcXHH3F6zI4mt3qVstA9cXNzN3Gq4LGh35mMWk4jExcUdc6vhlTdKJkHWPOjg4uIu5eZBM79k7QUoLi7uX+HmVybVKNwSZLi4uNu4+VVKbxTjByEuLu5BbrVQqQ5tJEVO9C/AxcU9wu1dfE4uP/I4G/V3cXFxO9wvpHK5aA33i3YAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/iOS/"><i class="fa fa-tag"></i>iOS</a></div><div class="post-nav"><a class="pre" href="/index.html">iOS - RunLoop 具体运用</a><a class="next" href="/20180101.html">归来仍是少年</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMTcyMy84Mjg3"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.zerocc.com.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E5%85%89%E6%B2%99%E6%BC%8F/">时光沙漏</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/index.html">iOS - RunLoop 具体运用</a></li><li class="post-list-item"><a class="post-list-link" href="/20151003.html">iOS 开发之 Socket 编程</a></li><li class="post-list-item"><a class="post-list-link" href="/20180101.html">归来仍是少年</a></li><li class="post-list-item"><a class="post-list-link" href="/20161023.html">只要最后是你就好</a></li><li class="post-list-item"><a class="post-list-link" href="/20190602.html">后来的我们</a></li><li class="post-list-item"><a class="post-list-link" href="/20181017.html">凌晨三点</a></li><li class="post-list-item"><a class="post-list-link" href="/20160405.html">念乡思你</a></li><li class="post-list-item"><a class="post-list-link" href="/20170420.html">漂洋过海来看你</a></li><li class="post-list-item"><a class="post-list-link" href="/index.html">iOS - 苹果内购</a></li><li class="post-list-item"><a class="post-list-link" href="/20180312.html">希望我们冷漠且礼貌的相处</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 25px;">iOS</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 20px;">源码阅读</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 22.5px;">随笔</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 17.5px;">心情</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">zerocc2014.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>