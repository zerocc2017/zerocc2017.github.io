<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>iOS - RunLoop 运行循环步骤源码解析 | zerocc2014</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS - RunLoop 运行循环步骤源码解析</h1><a id="logo" href="/.">zerocc2014</a><p class="description">桃李春风一杯酒，江湖夜雨十年灯</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/reads/"><i class="fa fa-folder"> 阅读</i></a><a href="/codes/"><i class="fa fa-star"> 干货</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS - RunLoop 运行循环步骤源码解析</h1><div class="post-meta">2016年08月11日</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-RunLoop-%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.</span> <span class="toc-text">一. RunLoop 运行循环具体步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%95%B4%E4%B8%AA%E5%86%85%E9%83%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二. 源码解析运行循环整个内部过程</span></a></li></ol></div></div><div class="post-content"><a id="more"></a>

<h1 id="一-RunLoop-运行循环具体步骤"><a href="#一-RunLoop-运行循环具体步骤" class="headerlink" title="一. RunLoop 运行循环具体步骤"></a>一. RunLoop 运行循环具体步骤</h1><h1 id="二-源码解析运行循环整个内部过程"><a href="#二-源码解析运行循环整个内部过程" class="headerlink" title="二. 源码解析运行循环整个内部过程"></a>二. 源码解析运行循环整个内部过程</h1><p><strong>1. RunLoop 对象的创建</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h </span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>);   <span class="comment">// 获取当前线程 runloop 对象</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>);      <span class="comment">// 获取主线程 runloop 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用示例，获取当前runloop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runloop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br></pre></td></tr></table></figure>
<p>RunLoop 既然是一个对象就必然有一个创建的过程，苹果不允许我们去自行创建 RunLoop 对象，其创建过程内部完成，只能通过函数获取当前线程的 RunLoop 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="comment">// 获取取主线程的 runloop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="comment">// 传入主线程</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前所在线程的 runloop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="comment">// 传入当前线程</span></span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CFRunLoopGetCurrent 函数必须要在线程内部调用，才能获取当前线程的RunLoop；CFRunLoopGetMain() 不管在主线程还是子线程中调用，都是得到主线程的RunLoop。<br>这两个获取线程 runloop 对象函数内部都调用了_CFRunLoopGet0() 函数，传入的参数是当前线程。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock = <span class="built_in">CFSpinLockInit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for &quot;main thread&quot; that always works</span></span><br><span class="line"><span class="comment">// 根据线程取 RunLoop</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果存储 runloop 的字典不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="comment">// 创建一个临时字典dict</span></span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 创建主线程的runloop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 把主线程的runloop保存到dict中，key是线程，value是runloop</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        <span class="comment">// 此处 NULL 和 __CFRunLoops 指针都指向 NULL，匹配，所以将 dict 写到 __CFRunLoops</span></span><br><span class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            <span class="comment">// 释放dict</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放 mainrunloop</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上说明，第一次进来的时候，不管是 getMainRunloop 还是get子线程的 runloop，主线程的 runloop 总是会被创建</span></span><br><span class="line">    <span class="comment">// 从字典 __CFRunLoops 中获取传入线程t的 runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果没有获取到</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 根据线程t创建一个runloop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="comment">// 把newLoop存入字典__CFRunLoops，key是线程t</span></span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果传入线程就是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时，销毁对应的runloop</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据线程创建一个runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> rlm;</span><br><span class="line">    <span class="comment">//计算一个内存大小用于创建CFRunLoopRef对象</span></span><br><span class="line">    uint32_t size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __CFRunLoop) - <span class="keyword">sizeof</span>(<span class="built_in">CFRuntimeBase</span>);</span><br><span class="line">    <span class="comment">//用runtime创建一个CFRunLoopRef对象</span></span><br><span class="line">    loop = (<span class="built_in">CFRunLoopRef</span>)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == loop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化runloop的各种标记状态</span></span><br><span class="line">    (<span class="keyword">void</span>)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    <span class="comment">//初始化一个唤醒端口，当需要唤醒runloop时，可以通过内核往该端口发送消息</span></span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CFPORT_NULL</span> == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    <span class="comment">//设置runloop为唤醒状态</span></span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    <span class="comment">//初始化_commonModes集合</span></span><br><span class="line">    loop-&gt;_commonModes = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    <span class="comment">//把kCFRunLoopDefaultMode加入_commonModes</span></span><br><span class="line">    <span class="built_in">CFSetAddValue</span>(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_currentMode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化_modes集合</span></span><br><span class="line">    loop-&gt;_modes = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_blocks_tail = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_counterpart = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//线程赋值为传入的线程</span></span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    loop-&gt;_winthread = GetCurrentThreadId();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    loop-&gt;_winthread = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//查找kCFRunLoopDefaultMode，此处传入true，所以没找到会创建一个</span></span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_CFRunLoopGet0() 函数调用 <code>__CFRunLoopCreate</code> 函数才是真正的 RunLoop 对象创建过程，源码中分析得到以下几点：</p>
<ul>
<li>线程和 RunLoop 是一一对应的，对应关系保存在一个以 key-value 的方式全局的 dictionary 中；</li>
<li>RunLoop 创建过程类似懒加载，只有在第一次获取的时候才创建，所以一个线程只有唯一以其对应的 RunLoop 对象；</li>
<li>主线程的 RunLoop 会在初始化全局字典时创建，子线程的 RunLoop 会在第一次获取的时候创建，如果不获取的话就一直不会被创建；</li>
<li>RunLoop 会在线程销毁时而销毁；</li>
</ul>
<p><strong>2. CFRunLoopAddCommonMode 创建 RunLoop 对象下的 mode</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 向 RunLoop 对象中添加 Mode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param rl RunLoop 对象</span></span><br><span class="line"><span class="comment"> @param modeName Mode 名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 看 RunLoop 对象中是否已经有这个 mode，如果有就什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">        <span class="comment">// 取RunLoop的_commonModeItems</span></span><br><span class="line">        <span class="built_in">CFSetRef</span> set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 把modeName添加到RunLoop的_commonModes中</span></span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            <span class="built_in">CFTypeRef</span> context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</span><br><span class="line">            <span class="comment">/* add all common-modes items to new mode */</span></span><br><span class="line">            <span class="comment">// 这里调用CFRunLoopAddSource/CFRunLoopAddObserver/CFRunLoopAddTimer的时候会调用，</span></span><br><span class="line">            <span class="comment">// __CFRunLoopFindMode(rl, modeName, true)，CFRunLoopMode对象在这个时候被创建</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="keyword">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>苹果不允许我们直接创建一个 CFRunLoopMode 对象，通过调用CFRunLoopAddCommonMode 函数传入一个字符串向 RunLoop 中添加 Mode，传入的字符串即为Mode的名字，Mode对象在 RunLoop 内部创建的。</p>
<ul>
<li>modeName 不能重复，modeName 是 mode 的唯一标识符；</li>
<li>RunLoop 对象中的 _commonModes 数组存放所有被标记为 common 的 mode 的名称；</li>
<li>添加 commonMode 会把 commonModeItems 数组中的所有 source 同步到新添加的 mode；</li>
<li>CFRunLoopMode 对象在 CFRunLoopAddItemsToCommonMode 函数中调用CFRunLoopFindMode 时被创建；</li>
</ul>
<p><strong>3. CFRunLoopAddSource 添加 RunLoop 中 mode 的 modeItem (Observer/Source/Timer), 这里分析 Source 的添加过程</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加source事件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param rl       rl 对象</span></span><br><span class="line"><span class="comment"> @param rls      需添加的 RunLoopSource 对象</span></span><br><span class="line"><span class="comment"> @param modeName 以modeName查询添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> rls, <span class="built_in">CFStringRef</span> modeName) &#123;	<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rls)) <span class="keyword">return</span>;</span><br><span class="line">    Boolean doVer0Callout = <span class="literal">false</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 如果是kCFRunLoopCommonModes</span></span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        <span class="comment">// 如果runloop的_commonModes存在，则copy一个新的复制给set</span></span><br><span class="line">        <span class="built_in">CFSetRef</span> set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">       <span class="comment">// 如果runl _commonModeItems为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            <span class="comment">// 先初始化</span></span><br><span class="line">            rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把传入的CFRunLoopSourceRef加入_commonModeItems</span></span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rls);</span><br><span class="line">        <span class="comment">// 如果set存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            <span class="built_in">CFTypeRef</span> context[<span class="number">2</span>] = &#123;rl, rls&#125;;</span><br><span class="line">            <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">            <span class="comment">// 则把set里的所有mode都执行一遍__CFRunLoopAddItemToCommonModes函数</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以上分支的逻辑就是，如果你往kCFRunLoopCommonModes里面添加一个source，那么所有_commonModes里的mode都会添加这个source</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 modeName 查找 mode，如果不存在，则创建一个</span></span><br><span class="line">        <span class="built_in">CFRunLoopModeRef</span> rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 如果_sources0不存在，则初始化_sources0，_sources0和_portToV1SourceMap</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; <span class="literal">NULL</span> == rlm-&gt;_sources0) &#123;</span><br><span class="line">            rlm-&gt;_sources0 = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">            rlm-&gt;_sources1 = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">            rlm-&gt;_portToV1SourceMap = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果_sources0和_sources1中都不包含传入的source</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !<span class="built_in">CFSetContainsValue</span>(rlm-&gt;_sources0, rls) &amp;&amp; !<span class="built_in">CFSetContainsValue</span>(rlm-&gt;_sources1, rls)) &#123;</span><br><span class="line">            <span class="comment">//如果version是0，则加到_sources0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">                <span class="built_in">CFSetAddValue</span>(rlm-&gt;_sources0, rls);</span><br><span class="line">                <span class="comment">// 如果version是1，则加到_sources1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">                <span class="built_in">CFSetAddValue</span>(rlm-&gt;_sources1, rls);</span><br><span class="line">                __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CFPORT_NULL</span> != src_port) &#123;</span><br><span class="line">                    <span class="comment">// 此处只有在加到source1的时候才会把souce和一个mach_port_t对应起来</span></span><br><span class="line">                    <span class="comment">// 说明只有source1可以通过内核向其端口发送消息来主动唤醒runloop</span></span><br><span class="line">                    <span class="built_in">CFDictionarySetValue</span>(rlm-&gt;_portToV1SourceMap, (<span class="keyword">const</span> <span class="keyword">void</span> *)(uintptr_t)src_port, rls);</span><br><span class="line">                    __CFPortSetInsert(src_port, rlm-&gt;_portSet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            __CFRunLoopSourceLock(rls);</span><br><span class="line">            <span class="comment">// 把runloop加入到source的_runLoops中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rls-&gt;_runLoops) &#123;</span><br><span class="line">                rls-&gt;_runLoops = <span class="built_in">CFBagCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeBagCallBacks); <span class="comment">// sources retain run loops!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">CFBagAddValue</span>(rls-&gt;_runLoops, rl);</span><br><span class="line">            __CFRunLoopSourceUnlock(rls);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">                    doVer0Callout = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (doVer0Callout) &#123;</span><br><span class="line">        <span class="comment">// although it looses some protection for the source, we have no choice but</span></span><br><span class="line">        <span class="comment">// to do this after unlocking the run loop and mode locks, to avoid deadlocks</span></span><br><span class="line">        <span class="comment">// where the source wants to take a lock which is already held in another</span></span><br><span class="line">        <span class="comment">// thread which is itself waiting for a run loop/mode lock</span></span><br><span class="line">        rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);	<span class="comment">/* CALLOUT */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 mode 中所管理的各种事件 Observer/Source/Timer，此分析以Source 事件为例：</p>
<ul>
<li>若modeName传入 kCFRunLoopCommonModes，则该 source 会被保存到 RunLoop 的_commonModeItems 中，且被添加到所有 commonMode 中；</li>
<li>若modeName传入的不是 kCFRunLoopCommonModes，则会先查找该Mode，如果没有，会创建一个；</li>
<li>同一个 source 在一个 mode 中只能被添加一次；</li>
</ul>
<p><strong>4. CFRunLoopRun 启动线程的 RunLoop 入口</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认运行runloop的kCFRunLoopDefaultMode</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;	<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 默认在kCFRunLoopDefaultMode下运行runloop</span></span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定特定 mode 启动 RunLoop</span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动线程的 RunLoop, 类似一个 do - while 循环，但是只能这么理解，do - while 循环线程还是占有 cpu 一直运行，这里循环是真正的线程等待节省 CPU 资源；启动 RunLoop 内部都是调用 CFRunLoopRunSpecific 函数启动的，方式有两种：一种是调用 CFRunLoopRun 函数是以 DefaultMode 方式启动，其中两个参数一个 RunLoop 对象是当前 RunLoop 对象，另一个是 modeName 参数传入 kCFRunLoopDefaultMode；另一种是调用 CFRunLoopRunInMode 函数以特定 mode 启动 RunLoop，通过 modeName 参数传入指定的一个 mode，运行起来之后，被指定的 mode 即为 currentMode；</p>
<p><strong>5. CFRunLoopRunSpecific 根据传入model 启动 RunLoop 中间过程</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指定mode运行runloop</span></span><br><span class="line"><span class="comment"> * @param rl 当前运行的runloop</span></span><br><span class="line"><span class="comment"> * @param modeName 需要运行的mode的name</span></span><br><span class="line"><span class="comment"> * @param seconds  runloop的超时时间</span></span><br><span class="line"><span class="comment"> * @param returnAfterSourceHandled 是否处理完事件就返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">//根据modeName找到本次运行的mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//如果没找到 || mode中没有注册任何事件，则就此停止，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        Boolean did = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    <span class="comment">//取_currentMode，保存为上一次运行的mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> previousMode = rl-&gt;_currentMode;</span><br><span class="line">    <span class="comment">//把即将开始运行的mode 赋值给_currentMode</span></span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="comment">//初始化一个result为kCFRunLoopRunFinished</span></span><br><span class="line">    int32_t result = kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通知observer即将进入runloop</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">// RunLoop 运行循环 run 起来的核心函数</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="comment">//10.通知observer已退出runloop</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 RunLoop 先通过调用启动入口函数后，再通过调用 CFRunLoopRunSpecific 这个中间函数判断 model 相关逻辑，最终调用 __CFRunLoopRun 函数实现真正的 run；</p>
<ul>
<li>传入的 mode 必须是一个存在的 mode 来运行 RunLoop，无则 run 失败；</li>
<li>指定运行的 mode 中必须包含 modeItem，至少一个 modeItem，无则 RunLoop 不运行或者退出；</li>
<li>在进入 run loop 之前通知observer，状态为 kCFRunLoopEntry；</li>
<li>进入 run loop 之后调用了 __CFRunLoopRun 函数获取对应 RunLoop 状态；</li>
<li>在退出 run loop之后通知 observer，状态为 kCFRunLoopExit；</li>
</ul>
<p><strong>_CFRunLoopRun 线程 RunLoop 运行循环 run 起来的核心函数</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  运行run loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param rl              运行的RunLoop对象</span></span><br><span class="line"><span class="comment"> *  @param rlm             运行的mode</span></span><br><span class="line"><span class="comment"> *  @param seconds         run loop超时时间</span></span><br><span class="line"><span class="comment"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</span></span><br><span class="line"><span class="comment"> *  @param previousMode    上一次运行的mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 返回4种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">    <span class="comment">//获取系统启动后的CPU运行时间，用于控制超时时间</span></span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果RunLoop或者mode是stop状态，则直接return，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mach端口，在内核中，消息在端口之间传递。 初始为0</span></span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    <span class="comment">//判断是否为主线程</span></span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="comment">//如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span></span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (<span class="built_in">CFRunLoopGetMain</span>() == rl) &amp;&amp; <span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(<span class="string">&quot;Unable to get port for run loop mode queue (%d)&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GCD管理的定时器，用于实现runloop超时机制</span></span><br><span class="line">    dispatch_source_t timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)malloc(<span class="keyword">sizeof</span>(*timeout_context));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//立即超时</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0</span>ULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">        timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">        timeout_context-&gt;rl = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFRetain</span>(rl);</span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000</span>ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000</span>ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//永不超时</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="built_in">UINT64_MAX</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标志位默认为true</span></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//记录最后runloop状态，用于return</span></span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个存放内核消息的缓冲池</span></span><br><span class="line">        uint8_t msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        mach_msg_header_t *msg = <span class="literal">NULL</span>;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        HANDLE livePort = <span class="literal">NULL</span>;</span><br><span class="line">        Boolean windowsMessageReceived = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//取所有需要监听的port</span></span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置RunLoop为可以被唤醒状态</span></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.通知observer，即将触发timer回调，处理timer事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">//3.通知observer，即将触发Source0回调</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行加入当前runloop的block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.处理source0事件</span></span><br><span class="line">        <span class="comment">//有事件处理返回true，没有事件返回false</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">//执行加入当前runloop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有Sources0事件处理 并且 没有超时，poll为false</span></span><br><span class="line">        <span class="comment">//如果有Sources0事件处理 或者 超时，poll都为true</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">            <span class="comment">//从缓冲区读取消息</span></span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            <span class="comment">//接收dispatchPort端口的消息，（接收source1事件）</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果接收到了消息的话，开始处理msg</span></span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.通知观察者RunLoop即将进入休眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        <span class="comment">//设置RunLoop为休眠状态</span></span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        <span class="comment">// do not do any user callouts after this point (after notifying of sleeping)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line">        </span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">                memset(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            <span class="comment">//接收waitSet端口的消息</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></span><br><span class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">            memset(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        <span class="comment">// Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</span></span><br><span class="line">        __CFRunLoopWaitForMultipleObjects(waitSet, <span class="literal">NULL</span>, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced. Also, we don&#x27;t want them left</span></span><br><span class="line">        <span class="comment">// in there if this function returns.</span></span><br><span class="line">        </span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        <span class="comment">//取消runloop的休眠状态</span></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">//通知观察者runloop被唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        <span class="keyword">if</span> (windowsMessageReceived) &#123;</span><br><span class="line">            <span class="comment">// These Win32 APIs cause a callout, so make sure we&#x27;re unlocked first and relocked after</span></span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_msgPump) &#123;</span><br><span class="line">                rlm-&gt;_msgPump();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MSG msg;</span><br><span class="line">                <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE | PM_NOYIELD)) &#123;</span><br><span class="line">                    TranslateMessage(&amp;msg);</span><br><span class="line">                    DispatchMessage(&amp;msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</span></span><br><span class="line">            <span class="comment">// Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&#x27;re just checking to see if the things are signalled right now -- we will wait on them again later.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Ignore the dispatch source (it&#x27;s not in the wait set anymore) and also don&#x27;t run the observers here since we are polling.</span></span><br><span class="line">            __CFRunLoopSetSleeping(rl);</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopWaitForMultipleObjects(waitSet, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">            <span class="comment">// If we have a new live port then it will be handled below as normal</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_NOTHING</span>();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span>();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="comment">// Always reset the wake up port, or risk spinning forever</span></span><br><span class="line">            ResetEvent(rl-&gt;_wakeUpPort);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">// On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &#x27;too early&#x27; for the next timer, and no timers are handled.</span></span><br><span class="line">            <span class="comment">// In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="keyword">void</span> *msg = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">                mach_msg_header_t *reply = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//处理source1事件</span></span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                    <span class="built_in">CFAllocatorDeallocate</span>(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">ibireme runloop 全面解读</a></p>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/CF/CF-855.17/">opensource CFRunLoop 源码下载</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">developer documentation RunLoop</a></p>
</blockquote>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>iOS - RunLoop 运行循环步骤源码解析</p><p><span>文章作者：</span>zerocc</p><p><span>发布时间：</span>2016年08月11日</p><p><span>原始链接：</span><a href="/20160811.html">http://www.zerocc.com.cn/20160811.html</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="http://www.zerocc.com.cn/20160811.html"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.zerocc.com.cn/20160811.html" data-id="ckgc1nl3b003ak6xbal102pk8" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3aQWrEMAwF0N7/0lPoqlCSfEl2ksLzasgM4XkWwvry11e8Pj/r9+e/T5Jvj965eOHi4o65n9N19OojYrKqb8DFxX2KWy1e+fNzYrnY4eLivoybfzs5JOHi4v4v7jk66VaqG8bFxX2WmzQqeYsyKW3LejVcXNwBtxeYrv28Pd/FxcVdNJXoBZ3n7c1k4eLi3sNNIo8F7coptxqU4OLi3sPthRcJa3KcungPLi7uNm51CJpfy5gUrMMnuLi4N3LPy1B1WLJqmFpoe3BxcZdy886idwErb4RGaFxc3A3c6kGnfDQplq1yl4aLi7uBOw9HJm3SaD6Mi4u7jVs9plSvZ1UL3MVWcXFxN3PzUpIcPqphazmawcXFvZHbizx6FzLyq1oXkx9cXNxt3HsuVawtari4uLu5+Vh00sbkYeuFBxcX90ZuHmJOhqO9UoiLi/sUN1950Zm8pzBEwcXF3cCdNzD5b3pFszkxxsXFHXPzopNsphe1JAURFxf3fm61ePWOLKPmBxcX95Xcahja+yMutoeLi/t6bq9gRYMTXFzcF3Cr4WaO7sUfC2IRXFzcAXd+uSrfat7k4OLiPsT9BsNolYw0K4/sAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/iOS-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>iOS 底层结构</a></div><div class="post-nav"><a class="pre" href="/20160815.html">搭建本地服务进行调试</a><a class="next" href="/index.html">iOS - RunLoop 详解及整体结构剖析</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMTcyMy84Mjg3"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.zerocc.com.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/">iOS - 开发日常</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E5%85%89%E6%B2%99%E6%BC%8F/">时光沙漏</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/1602816267.html">Widget Extension in iOS 14</a></li><li class="post-list-item"><a class="post-list-link" href="/20190602.html">后来的我们</a></li><li class="post-list-item"><a class="post-list-link" href="/20181017.html">凌晨三点</a></li><li class="post-list-item"><a class="post-list-link" href="/1602472154.html">hexo博客主题更换 maupassant 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/20181001.html">iOS - 苹果内购</a></li><li class="post-list-item"><a class="post-list-link" href="/20180312.html">希望我们冷漠且礼貌的相处</a></li><li class="post-list-item"><a class="post-list-link" href="/20180101.html">归来仍是少年</a></li><li class="post-list-item"><a class="post-list-link" href="/20171123.html">iOS 中证书和签名机制</a></li><li class="post-list-item"><a class="post-list-link" href="/1602472277.html">hexo博客必用插件</a></li><li class="post-list-item"><a class="post-list-link" href="/20170420.html">漂洋过海来看你</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 18.33px;">hexo</a> <a href="/tags/iOS-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 18.33px;">iOS 第三方源码阅读</a> <a href="/tags/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/" style="font-size: 15px;">终端指令</a> <a href="/tags/iOS/" style="font-size: 25px;">iOS</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 15px;">源码阅读</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 21.67px;">随笔</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/" style="font-size: 15px;">服务端</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">服务器</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size: 15px;">网络层</a> <a href="/tags/iOS-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" style="font-size: 15px;">iOS 底层结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">zerocc2014.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>